
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Symbolic generation of  evaluating functions.</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2025-05-12"><meta name="DC.source" content="blockA.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Symbolic generation of  evaluating functions.</h1><!--introduction--><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">Defining Variable Dependencies</a></li><li><a href="#3">Defining the variables derivatives in both spaces</a></li><li><a href="#13">Auxiliary Variables</a></li><li><a href="#22">Setting the Equations for Each Region</a></li><li><a href="#25">Setting Up the Full Equation System</a></li><li><a href="#35">Preparations for the numerical evaluation</a></li><li><a href="#40">Generate MATLAB functions for the equations and their Jacobians</a></li></ul></div><p>This is a fundamental subroutine of the 'JAM' method. It allows equations to be expressed in Cartesian coordinates using non-singular mappings and generates the analytical Jacobians required by the Newton method.</p><p>Since there are 5 unknowns in each region, we will reserve a cell array of the proper size to store all the equations.</p><pre class="codeinput">EQ = cell(NVAR(1),NRegion);
<span class="comment">%</span>
</pre><h2 id="2">Defining Variable Dependencies</h2><p>All variables will generally depend on the mapped independent variables in a time-dependent 3D space: [z0, r0, q0; t0]. For example, for the pressure in region 1, p1, we declare that:</p><p><img src="blockA_eq14152690679976440771.png" alt="$$&#xA; p1 = p1(r0, z0; t0)&#xA;$$" style="width:115px;height:15px;"></p><p>Note: Because this problem is 2D, the <i>q0</i> dependence has been removed.</p><pre class="codeinput">syms <span class="string">r0</span> <span class="string">z0</span> <span class="string">q0</span> <span class="string">t0</span> <span class="string">real</span>
<span class="keyword">for</span> kk = 1:NRegion
    <span class="keyword">for</span> j = 1:NVAR(kk)
        <span class="comment">% Declare symbolic variable</span>
        variable_name = sprintf(<span class="string">'%s%d(r0, z0, t0)'</span>, list_var{kk}{j}, kk);
        eval([<span class="string">'syms '</span> variable_name <span class="string">';'</span>]);
        eval(sprintf(<span class="string">'%s%d= %s;'</span>, list_var{kk}{j}, kk, variable_name));
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2 id="3">Defining the variables derivatives in both spaces</h2><pre class="codeinput"><span class="keyword">for</span> kk = 1:NRegion
</pre><pre class="codeinput">    <span class="comment">%Auxiliar variable "0"</span>
    <span class="keyword">for</span> j=1:NVAR(kk)
        eval(sprintf(<span class="string">'%s0= %s%d;'</span>, list_var{kk}{j}, list_var{kk}{j},kk));
    <span class="keyword">end</span>
</pre><p>The Jacobian <b>J</b> (and its inverse) allows expressing spatial derivatives from the physical coordinates to the mapped space coordinates and vice versa:</p><p><img src="blockA_eq12954969192781579250.png" alt="$$ J = \left(\begin{array}{ccc}&#xA;{\partial x}/{\partial r_o} &amp; {\partial x}/{\partial z_o} &amp; {\partial x}/{\partial q_o} \\&#xA;{\partial y}/{\partial r_o} &amp; {\partial y}/{\partial z_o} &amp; {\partial y}/{\partial q_o} \\&#xA;{\partial z}/{\partial r_o} &amp; {\partial z}/{\partial z_o} &amp; {\partial z}/{\partial q_o}&#xA;\end{array}\right) $$" style="width:230px;height:53px;"></p><pre class="codeinput">    X = [F0, G0, q0]; <span class="comment">% Physical domain: (y, x, z). Note: q0 (z-coordinate) is not used as the problem is 2D.</span>
    xs = [r0, z0, q0]; <span class="comment">% Mapped domain.</span>
    J = jacobian(X, xs);
    Jinv = simplify(inv(J));

    <span class="comment">% Getting the basis vectors for the mapped space bc{i}</span>
    Xc=[r0,z0,q0];
    <span class="comment">%1:r0-y</span>
    bc{1}=diff(Xc,r0);
    <span class="comment">%a:z0-x</span>
    bc{2}=diff(Xc,z0);
    <span class="comment">%c:t0-z</span>
    bc{3}=diff(Xc,q0);
    <span class="comment">% Selecting vector base ( bc)</span>
    bbase=bc;
</pre><p>Besides the geometrical Jacobian, we need to consider the time transformation mapping. Given, for example, the x-coordinate in the physical space:</p><p><img src="blockA_eq07893325013638590278.png" alt="$$ x = x(r_o, z_o, q_o ; t_o)$$" style="width:114px;height:15px;"></p><p>Differentiating the above expression with respect to physical time t, we get:</p><p><img src="blockA_eq04052506911468230202.png" alt="$$ \frac{d x}{d t} =  \frac{\partial x}{\partial t_o}  \frac{\partial&#xA;t_o}{\partial t} + \frac{\partial x}{\partial r_o}  \frac{\partial&#xA;r_o}{\partial t} + \frac{\partial x}{\partial z_o}  \frac{\partial&#xA;z_o}{\partial t} + \frac{\partial x}{\partial q_o}  \frac{\partial&#xA;q_o}{\partial t} $$" style="width:283px;height:34px;"></p><p>Note that (x, y, z) and t are independent variables, and in this case, <img src="blockA_eq01699602861745484819.png" alt="$t_o = t$" style="width:36px;height:12px;">. Therefore, <img src="blockA_eq16986159011864450450.png" alt="$\frac{\partial t_o}{\partial t} = 1$" style="width:42px;height:19px;">. Also, since x, y, z do not explicitly depend on t, <img src="blockA_eq10578710000161626254.png" alt="$\frac{d x}{d t} = 0$" style="width:40px;height:19px;">. The equation becomes:</p><p><img src="blockA_eq04602696361769350180.png" alt="$$ 0 = \frac{\partial x}{\partial t_o}&#xA;  + \frac{\partial x}{\partial r_o}  \frac{\partial r_o}{\partial t}&#xA;  + \frac{\partial x}{\partial z_o}  \frac{\partial z_o}{\partial t}&#xA;  + \frac{\partial x}{\partial q_o}  \frac{\partial q_o}{\partial t} $$" style="width:249px;height:34px;"></p><p>The same derivation applies to the other spatial variables (y, z).</p><p>This forms a system of equations allowing us to compute the grid velocities:</p><p><img src="blockA_eq16530841111025971306.png" alt="$$ \frac{\partial r_o}{\partial t}, \quad \frac{\partial z_o}{\partial t},&#xA;\quad \frac{\partial q_o}{\partial t}$$" style="width:113px;height:31px;"></p><p>These are named symbolically <i>dr0dt</i>, <i>dz0dt</i>, and <i>dq0dt</i>.</p><pre class="codeinput">    syms <span class="string">dr0dt</span>  <span class="string">dz0dt</span>  <span class="string">dq0dt</span> <span class="string">real</span>
    x=X(1);
    y=X(2);
    z=X(3);
    eqn1 = diff(x,t0) +diff(x,z0)*dz0dt +diff(x,r0)*dr0dt+diff(x,q0)*dq0dt==0;
    eqn2 = diff(y,t0) +diff(y,z0)*dz0dt +diff(y,r0)*dr0dt+diff(y,q0)*dq0dt==0;
    eqn3 = diff(z,t0) +diff(z,z0)*dz0dt +diff(z,r0)*dr0dt+diff(z,q0)*dq0dt==0;
    [Aeqn,Beqn]=equationsToMatrix([eqn1,eqn2,eqn3],[dr0dt,dz0dt,dq0dt]);
    Xeqn=linsolve(Aeqn,Beqn);
    dr0dt=simplify(Xeqn(1));
    dz0dt=simplify(Xeqn(2));
    dq0dt=simplify(Xeqn(3));
</pre><p>Derivatives in the physical space can be expressed in terms of derivatives in the mapped space using the inverse Jacobian (Jinv) calculated earlier.</p><pre class="codeinput">    <span class="keyword">for</span> j = 1:NVAR(kk)
</pre><pre class="codeinput">        var_name = sprintf(<span class="string">'%s%d'</span>, list_var{kk}{j},kk);
        <span class="comment">% First derivatives in X</span>
        eval(sprintf(<span class="string">'d%sdy = Jinv(1, 1) * diff(%s, xs(1)) + Jinv(2, 1) * diff(%s, xs(2))+ Jinv(3, 1) * diff(%s, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdx = Jinv(1, 2) * diff(%s, xs(1)) + Jinv(2, 2) * diff(%s, xs(2))+ Jinv(3, 2) * diff(%s, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdz = Jinv(1, 3) * diff(%s, xs(1)) + Jinv(2, 3) * diff(%s, xs(2))+ Jinv(3, 3) * diff(%s, xs(3));'</span>, var_name, var_name, var_name,var_name));
</pre><pre class="codeinput">        <span class="comment">%Similarly, time derivative would be:</span>
        eval(sprintf(<span class="string">'d%sdt = diff(%s,t0)+diff(%s,r0)*dr0dt+diff(%s,z0)*dz0dt+diff(%s,q0)*dq0dt;'</span>, var_name, var_name, var_name,var_name,var_name));
</pre><p>Second-order derivatives in physical coordinates are obtained using the chain rule again:</p><pre class="codeinput">        eval(sprintf(<span class="string">'d%sdyy = Jinv(1, 1) * diff(d%sdy, xs(1)) + Jinv(2, 1) * diff(d%sdy, xs(2))+ Jinv(3, 1) * diff(d%sdy, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdxx = Jinv(1, 2) * diff(d%sdx, xs(1)) + Jinv(2, 2) * diff(d%sdx, xs(2))+ Jinv(3, 2) * diff(d%sdx, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdzz = Jinv(1, 3) * diff(d%sdz, xs(1)) + Jinv(2, 3) * diff(d%sdz, xs(2))+ Jinv(3, 3) * diff(d%sdz, xs(3));'</span>, var_name, var_name, var_name,var_name));
</pre><p>Derivatives in the mapped space are straightforward:</p><pre class="codeinput">        eval(sprintf(<span class="string">'d%sdr0 = diff(%s, r0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdz0 = diff(%s, z0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdrr0 = diff(%s, r0, r0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdzz0 = diff(%s, z0, z0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdrz0 = diff(%s, r0, z0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdt0 = diff(%s, t0);'</span>, var_name, var_name));
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><h2 id="13">Auxiliary Variables</h2><p>In some cases, it's convenient to use auxiliary variables, such as the velocity vector in Cartesian coordinates:</p><p><img src="blockA_eq04426957335704879677.png" alt="$$ \mathbf{V} = v_y \mathbf{e_y} + v_x \mathbf{e_x} + v_z \mathbf{e_z} $$" style="width:150px;height:15px;"> Note: Assuming standard Cartesian (x,y,z) although code uses (y,x,z) based on F0, G0.</p><pre class="codeinput">    V=vy0*bbase{1}+vx0*bbase{2}+0*bbase{3};
</pre><p>If derivatives of auxiliary variables appear in the equations, the same differentiation procedure described above would be repeated for them.</p><pre class="codeinput">    list_aux={<span class="string">'V'</span>,<span class="string">'p0'</span>, <span class="string">'F0'</span>, <span class="string">'G0'</span>};
    <span class="keyword">for</span> j = 1:length(list_aux)
</pre><pre class="codeinput">        var_name = sprintf(<span class="string">'%s'</span>, list_aux{j});
        <span class="comment">% First derivatives in physical space (using the same logic as before)</span>
        eval(sprintf(<span class="string">'d%sdy = Jinv(1, 1) * diff(%s, xs(1)) + Jinv(2, 1) * diff(%s, xs(2))+ Jinv(3, 1) * diff(%s, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdx = Jinv(1, 2) * diff(%s, xs(1)) + Jinv(2, 2) * diff(%s, xs(2))+ Jinv(3, 2) * diff(%s, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdz = Jinv(1, 3) * diff(%s, xs(1)) + Jinv(2, 3) * diff(%s, xs(2))+ Jinv(3, 3) * diff(%s, xs(3));'</span>, var_name, var_name, var_name,var_name));
</pre><pre class="codeinput">        <span class="comment">%Time derivative:</span>
        eval(sprintf(<span class="string">'d%sdt = diff(%s,t0)+diff(%s,r0)*dr0dt+diff(%s,z0)*dz0dt+diff(%s,q0)*dq0dt;'</span>, var_name, var_name, var_name,var_name,var_name));
</pre><p>Second order derivatives:</p><pre class="codeinput">        eval(sprintf(<span class="string">'d%sdyy = Jinv(1, 1) * diff(d%sdy, xs(1)) + Jinv(2, 1) * diff(d%sdy, xs(2))+ Jinv(3, 1) * diff(d%sdy, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdxx = Jinv(1, 2) * diff(d%sdx, xs(1)) + Jinv(2, 2) * diff(d%sdx, xs(2))+ Jinv(3, 2) * diff(d%sdx, xs(3));'</span>, var_name, var_name, var_name,var_name));
        eval(sprintf(<span class="string">'d%sdzz = Jinv(1, 3) * diff(d%sdz, xs(1)) + Jinv(2, 3) * diff(d%sdz, xs(2))+ Jinv(3, 3) * diff(d%sdz, xs(3));'</span>, var_name, var_name, var_name,var_name));
</pre><p>Derivatives in mapped space:</p><pre class="codeinput">        eval(sprintf(<span class="string">'d%sdr0 = diff(%s, r0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdz0 = diff(%s, z0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdrr0 = diff(%s, r0, r0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdzz0 = diff(%s, z0, z0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdrz0 = diff(%s, r0, z0);'</span>, var_name, var_name));
        eval(sprintf(<span class="string">'d%sdt0 = diff(%s, t0);'</span>, var_name, var_name));
</pre><pre class="codeinput">    <span class="keyword">end</span>
</pre><p>Setting up auxiliary velocity operators simplifies writing the equations: Examples: Velocity gradient, rate-of-strain tensor, vorticity tensor, convective term.</p><p><img src="blockA_eq11869753032224307502.png" alt="$$ \nabla \mathbf{v}, \: (\nabla \mathbf{v} + \nabla^T \mathbf{v})/2 , \: (\nabla \mathbf{v} - \nabla^T \mathbf{v})/2, , \: \mathbf{v} \cdot \nabla \mathbf{v},...$$" style="width:306px;height:17px;"></p><pre class="codeinput">    gradientV=[dVdy.',dVdx.',dVdz.']; <span class="comment">%$\nabla \mathbf{v}$</span>
    DD=(gradientV+gradientV.')/2; <span class="comment">%$(\nabla \mathbf{v} + \nabla^T \mathbf{v})/2$</span>
    WW=(gradientV-gradientV.')/2; <span class="comment">%$(\nabla \mathbf{v} - \nabla^T \mathbf{v})/2$</span>
    VnablaV=vx1*zeros(1,3);
    <span class="keyword">for</span> i=1:3
        VnablaV(i)=simplify(V(1)*dVdy(i)+V(2)*dVdx(i)+V(3)*dVdz(i)); <span class="comment">%$\mathbf{v} \dot \nabla \mathbf{v}$</span>
    <span class="keyword">end</span>
    laplaceV=simplify(dVdxx+dVdyy+dVdzz); <span class="comment">%Laplace operator</span>
    gradientP=[dp0dy,dp0dx,dp0dz]; <span class="comment">%pressure gradient</span>
    divergencV=simplify(dVdx(2)+dVdy(1)+dVdz(3)); <span class="comment">%divergence of the velocity</span>
</pre><p>Also, for the quasi-elliptic transformation mapping from Dimakopoulos &amp; Tsamopoulos (2003), we introduce the following auxiliary functions related to the mesh mapping: F0, G0 likely represent the physical coordinates y, x as functions of mapped r0, z0.</p><pre class="codeinput">    g11=dG0dz0^2+dF0dz0^2;
    g22=dG0dr0^2+dF0dr0^2;
    g12=dG0dr0*dG0dz0+dF0dr0*dF0dz0;
    JJ=dG0dr0*dF0dz0-dG0dz0*dF0dr0;
    eps1=0.3;
    D1=eps1*((dF0dz0^2+dG0dz0^2)/(dF0dr0^2+dG0dr0^2))^0.5+(1-eps1);
    dD1dr0=diff(D1,r0);
    dD1dz0=diff(D1,z0);
    Q1=-(dD1dr0*dF0dz0-dD1dz0*dF0dr0)*JJ/D1;
    <span class="comment">%</span>
</pre><h2 id="22">Setting the Equations for Each Region</h2><p>Using the auxiliary variables defined above, the governing equations (e.g., Navier-Stokes) become simpler to write. Example: Dimensionless Momentum equation (assuming incompressible flow)</p><pre class="codeinput">    MOMENTUM=-(dVdt+VnablaV)-gradientP+laplaceV/Re;
</pre><p>that proyecting in base bc is</p><pre class="codeinput">    MOMENTUMP=0*MOMENTUM;
    <span class="keyword">for</span> i=1:3
        MOMENTUMP(i)=(MOMENTUM*(bc{i}.'));
    <span class="keyword">end</span>
    <span class="comment">%2D momentum</span>
    EQ{1,kk}=MOMENTUMP(1); <span class="comment">%axial momentum</span>
    EQ{2,kk}=MOMENTUMP(2); <span class="comment">%radial mometum</span>
    EQ{3,kk}=divergencV; <span class="comment">%conservation</span>
    EQ{4,kk}=g22*dF0dzz0+g11*dF0drr0-2*g12*dF0drz0-Q1; <span class="comment">%</span>
    EQ{5,kk}=g22*dG0dzz0+g11*dG0drr0-2*g12*dG0drz0; <span class="comment">%</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="25">Setting Up the Full Equation System</h2><p>To facilitate numerical implementation and avoid complex indexing for different regions/boundaries, unknowns originating in a specific region are formally extended to all other regions. Their values (and corresponding equations) outside their original region are set to zero. In the conceptual diagram below, these artificially extended unknowns/equations are shown in red.</p><p>
<object type="image/svg+xml" data="equation.svg" width="400" height="300"> </object>
</p><p>Therefore, the equations for these 'ghost' unknowns must enforce that they are zero. At each node/location (total Nequations corresponding to different boundary/interior types), we define a full array of NVA equations (total number of variables across all regions). Only those equations involving unknowns actually present at that location are physically meaningful.</p><p>By default, we initialize the equation array at each location to set all NVA variables to zero. This handles the 'ghost' variables correctly.</p><p>At each location type k (1 to <i>Nequations</i>), the full set of equations FFk initially enforces FFk(i) = variable_i = 0 for all i.</p><pre class="codeinput"><span class="keyword">for</span> k = 1:Nequations
    eq_name = sprintf(<span class="string">'FF%d'</span>, k);
    eval(sprintf(<span class="string">'%s = sym(zeros(NVA, 1));'</span>, eq_name));
    lv=0;
    <span class="keyword">for</span> j = 1:NRegion
        <span class="keyword">for</span> i = 1:NVAR(j)
            variable_name = list_var{j}{i}; <span class="comment">% Get the variable name</span>
            lv=lv+1;
            eval(sprintf(<span class="string">'%s(%d)=%s%d;'</span>, eq_name,lv,variable_name,j));
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p>Now, overwrite the default zero equations with the actual governing equations or boundary conditions that apply at each specific location type. Location 1: Interior of Region 1 The first NVAR(1) equations (corresponding to region 1 variables) are replaced.</p><p><img src="blockA_eq16492831389064502735.png" alt="$$ \begin{array}{llcl}&#xA;F1(1) = 0 = &amp; v_{y1} &amp; \Leftarrow &amp; (\partial_t \mathbf{v}_1 + \mathbf{v}_1 \cdot \nabla \mathbf{v}_1 + \nabla p_1 -\nabla^2 \mathbf{v}_1/Re) \cdot \mathbf{e}_y \\&#xA;F1(2) = 0 = &amp; v_{x1} &amp; \Leftarrow &amp; (\partial_t \mathbf{v}_1 + \mathbf{v}_1 \cdot \nabla \mathbf{v}_1 + \nabla p_1 -\nabla^2 \mathbf{v}_1/Re) \cdot \mathbf{e}_x \\&#xA;F1(3) = 0 = &amp; p_{1} &amp; \Leftarrow &amp;  \nabla \cdot \mathbf{v}_1\\&#xA;F1(4) = 0 = &amp; F_{1} &amp; \Leftarrow  &amp;  ...\\&#xA;F1(5) = 0 = &amp; G_{1} &amp; \Leftarrow &amp;   ...\\&#xA;F1(6) = 0 = &amp; v_{y2} &amp;   &amp; \\&#xA;F1(7) = 0 = &amp; v_{x2} &amp;  &amp; \\&#xA;F1(8) = 0 = &amp; p_{2} &amp;   &amp; \\&#xA;F1(9) = 0 = &amp; F_{2} &amp;   &amp; \\&#xA;F1(10) = 0 = &amp; G_{2} &amp;  &amp; \\&#xA;\end{array} $$" style="width:417px;height:175px;"></p><pre class="codeinput">FF1(1)=EQ{1,1};
FF1(2)=EQ{2,1};
FF1(3)=EQ{3,1};
FF1(4)=EQ{4,1};
FF1(5)=EQ{5,1};
</pre><p>Location 2: Interior of Region 2 Equations corresponding to region 2 variables (indices NVAR(1)+1 to NVA) are replaced.</p><p><img src="blockA_eq02192734578103272116.png" alt="$$ \begin{array}{llcl}&#xA;F2(1) = 0 = &amp; v_{y1} &amp;   &amp; \\&#xA;F2(2) = 0 = &amp; v_{x1} &amp;  &amp; \\&#xA;F2(3) = 0 = &amp; p_{1} &amp;   &amp; \\&#xA;F2(4) = 0 = &amp; F_{1} &amp;   &amp; \\&#xA;F2(5) = 0 = &amp; G_{1} &amp;  &amp; \\&#xA;F2(6) = 0 = &amp; v_{y2} &amp; \Leftarrow &amp; (\partial_t \mathbf{v}_2 + \mathbf{v}_2 \cdot \nabla \mathbf{v}_2 + \nabla p_2 -\nabla^2 \mathbf{v}_2/Re) \cdot \mathbf{e}_y \\&#xA;F2(7) = 0 = &amp; v_{x2} &amp; \Leftarrow &amp; (\partial_t \mathbf{v}_2 + \mathbf{v}_2 \cdot \nabla \mathbf{v}_2 + \nabla p_2 -\nabla^2 \mathbf{v}_2/Re) \cdot \mathbf{e}_x \\&#xA;F2(8) = 0 = &amp; p_{2} &amp; \Leftarrow  &amp;  \nabla \cdot \mathbf{v}_2\\&#xA;F2(9) = 0 = &amp; F_{2} &amp; \Leftarrow  &amp;  ...\\&#xA;F2(10) = 0 = &amp; G_{2} &amp; \Leftarrow  &amp;   ...\\&#xA;\end{array} $$" style="width:417px;height:174px;"></p><pre class="codeinput">FF2(6)=EQ{1,2};
FF2(7)=EQ{2,2};
FF2(8)=EQ{3,2};
FF2(9)=EQ{4,2};
FF2(10)=EQ{5,2};
</pre><p>Location 3: Inlet Boundary (Affects both regions) Specify inlet boundary conditions for all variables.</p><p><img src="blockA_eq16099621587829520355.png" alt="$$ \begin{array}{llcl}&#xA;F3(1) = 0 = &amp; v_{y1} &amp; \Leftarrow  &amp; v_{y1}   \\&#xA;F3(2) = 0 = &amp; v_{x1} &amp; \Leftarrow &amp; v_{x1} -1 \\&#xA;F3(3) = 0 = &amp; p_{1} &amp;  \Leftarrow &amp; \partial_x p_1\\&#xA;F3(4) = 0 = &amp; F_{1} &amp; \Leftarrow  &amp; F_1 -Y_1 \\&#xA;F3(5) = 0 = &amp; G_{1} &amp; \Leftarrow &amp;  G_1 - X_1 \\&#xA;F3(6) = 0 = &amp; v_{y2} &amp; \Leftarrow &amp; v_{y2} \\&#xA;F3(7) = 0 = &amp; v_{x2} &amp; \Leftarrow &amp; v_{x2}-1\\&#xA;F3(8) = 0 = &amp; p_{2} &amp; \Leftarrow  &amp; \partial_x p_2\\&#xA;F3(9) = 0 = &amp; F_{2} &amp; \Leftarrow  &amp; F_2 -Y_2\\&#xA;F3(10) = 0 = &amp; G_{2} &amp; \Leftarrow  &amp; G_2 -X_2\\&#xA;\end{array} $$" style="width:217px;height:174px;"></p><pre class="codeinput">FF3(1)=vy1;
FF3(2)=vx1-1;
FF3(3)=dp1dx;
FF3(4)=F1-Y1;
FF3(5)=G1-X1;
FF3(6)=vy2;
FF3(7)=vx2-1;
FF3(8)=dp2dx;
FF3(9)=F2-Y2;
FF3(10)=G2-X2;
</pre><p>Location 4: Outlet Boundary (Affects both regions) Specify outlet boundary conditions.</p><p><img src="blockA_eq17098061725753993086.png" alt="$$ \begin{array}{llcl}&#xA;F4(1) = 0 = &amp; v_{y1} &amp; \Leftarrow  &amp; v_{y1}   \\&#xA;F4(2) = 0 = &amp; v_{x1} &amp; \Leftarrow &amp; v_{x1} -1 \\&#xA;F4(3) = 0 = &amp; p_{1} &amp;  \Leftarrow &amp; p_1\\&#xA;F4(4) = 0 = &amp; F_{1} &amp; \Leftarrow  &amp; F_1 -Y_1 \\&#xA;F4(5) = 0 = &amp; G_{1} &amp; \Leftarrow &amp;  G_1 - X_1 \\&#xA;F4(6) = 0 = &amp; v_{y2} &amp; \Leftarrow &amp; v_{y2} \\&#xA;F4(7) = 0 = &amp; v_{x2} &amp; \Leftarrow &amp; v_{x2}-1\\&#xA;F4(8) = 0 = &amp; p_{2} &amp; \Leftarrow  &amp; p_2\\&#xA;F4(9) = 0 = &amp; F_{2} &amp; \Leftarrow  &amp; F_2 -Y_2\\&#xA;F4(10) = 0 = &amp; G_{2} &amp; \Leftarrow  &amp; G_2 -X_2\\&#xA;\end{array} $$" style="width:217px;height:174px;"></p><pre class="codeinput">FF4(1)=vy1;
FF4(2)=dvx1dx;
FF4(3)=p1;
FF4(4)=F1-Y1;
FF4(5)=G1-X1;
FF4(6)=vy2;
FF4(7)=dvx2dx;
FF4(8)=p2;
FF4(9)=F2-Y2;
FF4(10)=G2-X2;
</pre><p>Location 5: Interface between Region 1 and Region 2 Impose continuity of velocity, normal stress, and mesh position. Assuming y-direction is normal to the interface.</p><p><img src="blockA_eq01556234006585595269.png" alt="$$ \begin{array}{llcl}&#xA;F5(1) = 0 = &amp; v_{y1} &amp; \Leftarrow  &amp; v_{y1} - v_{y2}  \\&#xA;F5(2) = 0 = &amp; v_{x1} &amp; \Leftarrow &amp;  v_{x1} - v_{x2} \\&#xA;F5(3) = 0 = &amp; p_{1} &amp;  \Leftarrow &amp; p_1 -p_2\\&#xA;F5(4) = 0 = &amp; F_{1} &amp; \Leftarrow  &amp; F_1 -Y_1 \\&#xA;F5(5) = 0 = &amp; G_{1} &amp; \Leftarrow &amp;  G_1 -X_1 \\&#xA;F5(6) = 0 = &amp; v_{y2} &amp; \Leftarrow &amp; \partial_y v_{y1} - \partial_y v_{y2} \\&#xA;F5(7) = 0 = &amp; v_{x2} &amp; \Leftarrow &amp; \partial_y v_{x1} - \partial_y v_{x2}\\&#xA;F5(8) = 0 = &amp; p_{2} &amp; \Leftarrow  &amp; \partial_y p_1 -\partial_y p_2\\&#xA;F5(9) = 0 = &amp; F_{2} &amp; \Leftarrow  &amp; F_2 -Y_2\\&#xA;F5(10) = 0 = &amp; G_{2} &amp; \Leftarrow  &amp; G_2 -X_2\\&#xA;\end{array} $$" style="width:247px;height:174px;"></p><pre class="codeinput">FF5(1)=vy1-vy2;
FF5(2)=vx1-vx2;
FF5(3)=p1-p2;
FF5(4)=F1-Y1;
FF5(5)=G1-X1;
FF5(6)=dvy1dy-dvy2dy;
FF5(7)=dvx1dy-dvx2dy;
FF5(8)=dp1dy-dp2dy;
FF5(9)=F2-Y2;
FF5(10)=G2-X2;
</pre><p>Location 6: Bottom boundary.</p><p><img src="blockA_eq05709953916693514250.png" alt="$$ \begin{array}{llcl}&#xA;F6(1) = 0 = &amp; v_{y1} &amp; \Leftarrow  &amp; v_{y1}   \\&#xA;F6(2) = 0 = &amp; v_{x1} &amp; \Leftarrow &amp; \partial_y v_{x1} \\&#xA;F6(3) = 0 = &amp; p_{1} &amp;  \Leftarrow &amp; \partial_y p_1\\&#xA;F6(4) = 0 = &amp; F_{1} &amp; \Leftarrow  &amp; F_1 -Y_1 \\&#xA;F6(5) = 0 = &amp; G_{1} &amp; \Leftarrow &amp;  \partial_{z_o z_o} G_1\\&#xA;F6(6) = 0 = &amp; v_{y2} &amp;  &amp; \\&#xA;F6(7) = 0 = &amp; v_{x2} &amp;  &amp; \\&#xA;F6(8) = 0 = &amp; p_{2} &amp;   &amp; \\&#xA;F6(9) = 0 = &amp; F_{2} &amp;   &amp; \\&#xA;F6(10) = 0 = &amp; G_{2} &amp;  &amp; \\&#xA;\end{array} $$" style="width:211px;height:174px;"></p><pre class="codeinput">FF6(1)=vy1;
FF6(2)=dvx1dy;
FF6(3)=dp1dy;
FF6(4)=F1-Y1;
FF6(5)=dG1dzz0;
</pre><p>Location 7: Top Boundary Similar to Location 6, but applies only to Region 2 variables.</p><p><img src="blockA_eq12250360954904513310.png" alt="$$ \begin{array}{llcl}&#xA;F7(1) = 0 = &amp; v_{y1} &amp;   &amp; \\&#xA;F7(2) = 0 = &amp; v_{x1} &amp;  &amp;  \\&#xA;F7(3) = 0 = &amp; p_{1} &amp;   &amp;  \\&#xA;F7(4) = 0 = &amp; F_{1} &amp;   &amp;  \\&#xA;F7(5) = 0 = &amp; G_{1} &amp;  &amp;   \\&#xA;F7(6) = 0 = &amp; v_{y2} &amp; \Leftarrow &amp; v_{y2} \\&#xA;F7(7) = 0 = &amp; v_{x2} &amp; \Leftarrow &amp; \partial_y v_{x2}\\&#xA;F7(8) = 0 = &amp; p_{2} &amp; \Leftarrow  &amp; \partial_y p_2\\&#xA;F7(9) = 0 = &amp; F_{2} &amp; \Leftarrow  &amp; F_2 -Y_2\\&#xA;F7(10) = 0 = &amp; G_{2} &amp; \Leftarrow  &amp; \partial_{z_o z_o} G_2\\&#xA;\end{array} $$" style="width:211px;height:174px;"></p><pre class="codeinput">FF7(6)=vy2;
FF7(7)=dvx2dy;
FF7(8)=dp2dy;
FF7(9)=F2-Y2;
FF7(10)=dG2dzz0;
</pre><p>Location 8: Cylinder Surface Boundary (Affects both regions if interface) Example: No-slip cylinder wall, fixed position. Normal direction is likely r0.</p><p><img src="blockA_eq07401619536696342157.png" alt="$$ \begin{array}{llcl}&#xA;F8(1) = 0 = &amp; v_{y1} &amp; \Leftarrow  &amp; v_{y1}   \\&#xA;F8(2) = 0 = &amp; v_{x1} &amp; \Leftarrow &amp; v_{x1} \\&#xA;F8(3) = 0 = &amp; p_{1} &amp;  \Leftarrow &amp; \partial_{n} p_1\\&#xA;F8(4) = 0 = &amp; F_{1} &amp; \Leftarrow  &amp; F_1 -Y_1 \\&#xA;F8(5) = 0 = &amp; G_{1} &amp; \Leftarrow &amp;  G_1 - X_1 \\&#xA;F8(6) = 0 = &amp; v_{y2} &amp; \Leftarrow &amp; v_{y2} \\&#xA;F8(7) = 0 = &amp; v_{x2} &amp; \Leftarrow &amp; v_{x2}\\&#xA;F8(8) = 0 = &amp; p_{2} &amp; \Leftarrow  &amp; \partial_n p_2\\&#xA;F8(9) = 0 = &amp; F_{2} &amp; \Leftarrow  &amp; F_2 -Y_2\\&#xA;F8(10) = 0 = &amp; G_{2} &amp; \Leftarrow  &amp; F_2 -X_2\\&#xA;\end{array} $$" style="width:217px;height:174px;"></p><pre class="codeinput">FF8(1)=vy1;
FF8(2)=vx1;
FF8(3)=dp1dr0; <span class="comment">% r0 is the normal</span>
FF8(4)=F1-Y1;
FF8(5)=G1-X1;
FF8(6)=vy2;
FF8(7)=vx2;
FF8(8)=dp2dr0; <span class="comment">% r0 is the normal</span>
FF8(9)=F2-Y2;
FF8(10)=G2-X2;
</pre><h2 id="35">Preparations for the numerical evaluation</h2><p>Once the symbolic equations (FF1, FF2, ..., FF8) are defined, it's more practical for numerical evaluation to substitute symbolic variable names and their derivatives with indexed array names. Example: The pressure in region 1 (p1), which is the 3rd variable (v=3) in region 1 (k=1) with no derivatives (d=1), will be substituted by yb1v3d1.</p><p><img src="blockA_eq03999428595247130204.png" alt="$$ p_1 \Leftrightarrow yb1v3d1 $$" style="width:87px;height:14px;"></p><p>Similarly, the second derivative of G (5th variable, v=5) in region 2 (k=2) with respect to z0 (assuming this corresponds to the 5th derivative index, d=5) would be represented as yb2v5d5.</p><p><img src="blockA_eq02403192526064046937.png" alt="$$ \frac{\partial^2 G_2}{\partial z_o^2} \Leftrightarrow yb2v5d5 $$" style="width:108px;height:37px;"></p><p>First, create symbolic arrays for the numerical variables (yF) and the corresponding symbolic expressions involving base variables and derivatives (yFsym).</p><pre class="codeinput">yFF=cell(1,NRegion);  <span class="comment">%Will be the real variable</span>
yFFsym=cell(1,NRegion); <span class="comment">% symbolic matrix</span>
<span class="keyword">for</span> kk=1:NRegion
    yFF{kk} = sym(<span class="string">'yF'</span>, [NVAR(kk), NDA], <span class="string">'real'</span>); <span class="comment">% Preallocating symbolic array</span>
    yFFsym{kk} = sym(<span class="string">'yFsym'</span>, [NVAR(kk), NDA], <span class="string">'real'</span>);
    <span class="keyword">for</span> l = 1:NVAR(kk)
        <span class="keyword">for</span> k = 1:NDA  <span class="comment">% Derivatives</span>
            yFF{kk}(l, k) = sym([<span class="string">'yb'</span>, num2str(kk), <span class="string">'v'</span>, num2str(l), <span class="string">'d'</span>, num2str(k)], <span class="string">'real'</span>);
            <span class="keyword">if</span> k == 1
                name = sprintf(<span class="string">'yFFsym{kk}(l, 1) = %s%d;'</span>, list_var{kk}{l},kk);
            <span class="keyword">else</span>
                name = sprintf(<span class="string">'yFFsym{kk}(l, %d) = diff(%s%d%s;'</span>, k, list_var{kk}{l},kk, list_dersymbolic{k});
            <span class="keyword">end</span>
            eval(name);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
yFsym = vertcat(yFFsym{:});
yF = vertcat(yFF{:});
</pre><p>Perform the substitution in the previously defined equation sets (FF1, ..., FF8) Replace the symbolic expressions (like p1, diff(G2,z0,z0)) with their numerical placeholders (yb1v3d1, yb2v5d5). Substitution is done from highest order derivatives to lowest to ensure correctness.</p><pre class="codeinput"><span class="keyword">for</span> le = 1:Nequations
</pre><pre class="codeinput">    eq_name = sprintf(<span class="string">'FF%d'</span>, le);
    eval(sprintf(<span class="string">'Eq = %s;'</span>, eq_name));
    k = 1:NVA;
    i = NDA:-1:1;
    Eq = subs(Eq, yFsym(k, i), yF(k, i));
</pre><p>Because 2D we force q0=0 in all the equations in order to simplify</p><pre class="codeinput">    Eq = subs(Eq, q0, 0);
    eval(sprintf(<span class="string">'%s = Eq;'</span>, eq_name));
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="40">Generate MATLAB functions for the equations and their Jacobians</h2><p>The final step is to convert the symbolic equations (now in terms of placeholders ybKvLdM) and their Jacobians into efficient MATLAB function files for numerical solving.</p><pre class="codeinput"><span class="comment">% Reshape the numerical placeholder matrix yF into a single column vector 'x'.</span>
<span class="comment">% This represents the vector of unknowns that the numerical solver will handle.</span>
x = reshape(yF', NVA * NDA, 1); <span class="comment">% Variables and derivatives</span>
<span class="keyword">for</span> i = 1:Nequations
    eq_name = sprintf(<span class="string">'FF%d'</span>, i);
    dFF_name = sprintf(<span class="string">'dFF%d'</span>, i);
    eval(sprintf(<span class="string">'%s = sym(zeros(NVA, NVA * NDA));'</span>, dFF_name));
    k = 1:NVA;
    eval(sprintf(<span class="string">'%s(k, :) = jacobian(%s(k), x);'</span>, dFF_name, eq_name));
    file_name = sprintf(<span class="string">'%sequationF%d'</span>, pathequation, i);
    eval(sprintf(<span class="string">'matlabFunction(%s, %s, ''File'', ''%s'', ''Vars'', {z0, r0, x, pa});'</span>, eq_name, dFF_name, file_name));
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Symbolic generation of  evaluating functions.

%%
% This is a fundamental subroutine of the 'JAM' method. It allows equations
% to be expressed in Cartesian coordinates using non-singular mappings
% and generates the analytical Jacobians required by the Newton method.
%
% Since there are 5 unknowns in each region, we will reserve a cell array
% of the proper size to store all the equations.
%
EQ = cell(NVAR(1),NRegion);
% 
%% Defining Variable Dependencies
% All variables will generally depend on the mapped independent variables
% in a time-dependent 3D space: [z0, r0, q0; t0]. For example, for the
% pressure in region 1, p1, we declare that:
%
% $$
%  p1 = p1(r0, z0; t0)
% $$
%
% Note: Because this problem is 2D, the _q0_ dependence has been removed.
%
syms r0 z0 q0 t0 real
for kk = 1:NRegion
    for j = 1:NVAR(kk)
        % Declare symbolic variable
        variable_name = sprintf('%s%d(r0, z0, t0)', list_var{kk}{j}, kk);
        eval(['syms ' variable_name ';']);
        eval(sprintf('%s%d= %s;', list_var{kk}{j}, kk, variable_name));
    end
end
%% Defining the variables derivatives in both spaces
% 
for kk = 1:NRegion
    %Auxiliar variable "0"
    for j=1:NVAR(kk)
        eval(sprintf('%s0= %s%d;', list_var{kk}{j}, list_var{kk}{j},kk));
    end

    %%
    % The Jacobian *J* (and its inverse) allows expressing spatial derivatives
    % from the physical coordinates to the mapped space coordinates and vice versa:
    %
    % $$ J = \left(\begin{array}{ccc}
    % {\partial x}/{\partial r_o} & {\partial x}/{\partial z_o} & {\partial x}/{\partial q_o} \\
    % {\partial y}/{\partial r_o} & {\partial y}/{\partial z_o} & {\partial y}/{\partial q_o} \\
    % {\partial z}/{\partial r_o} & {\partial z}/{\partial z_o} & {\partial z}/{\partial q_o}
    % \end{array}\right) $$
    %
    X = [F0, G0, q0]; % Physical domain: (y, x, z). Note: q0 (z-coordinate) is not used as the problem is 2D.
    xs = [r0, z0, q0]; % Mapped domain.
    J = jacobian(X, xs);
    Jinv = simplify(inv(J));

    % Getting the basis vectors for the mapped space bc{i}
    Xc=[r0,z0,q0];
    %1:r0-y
    bc{1}=diff(Xc,r0);
    %a:z0-x
    bc{2}=diff(Xc,z0);
    %c:t0-z
    bc{3}=diff(Xc,q0);
    % Selecting vector base ( bc)
    bbase=bc;

    %%
    % Besides the geometrical Jacobian, we need to consider the
    % time transformation mapping. Given, for example,
    % the x-coordinate in the physical space:
    %
    % $$ x = x(r_o, z_o, q_o ; t_o)$$
    %
    % Differentiating the above expression with respect to physical time t, we get:
    %
    % $$ \frac{d x}{d t} =  \frac{\partial x}{\partial t_o}  \frac{\partial
    % t_o}{\partial t} + \frac{\partial x}{\partial r_o}  \frac{\partial
    % r_o}{\partial t} + \frac{\partial x}{\partial z_o}  \frac{\partial
    % z_o}{\partial t} + \frac{\partial x}{\partial q_o}  \frac{\partial
    % q_o}{\partial t} $$
    %
    % Note that (x, y, z) and t are independent variables, and 
    % in this case, $t_o = t$. Therefore, $\frac{\partial t_o}{\partial t} = 1$. Also, 
    % since x, y, z do not explicitly depend on t, $\frac{d x}{d t} = 0$.
    % The equation becomes:
    %
    % $$ 0 = \frac{\partial x}{\partial t_o}
    %   + \frac{\partial x}{\partial r_o}  \frac{\partial r_o}{\partial t}
    %   + \frac{\partial x}{\partial z_o}  \frac{\partial z_o}{\partial t}
    %   + \frac{\partial x}{\partial q_o}  \frac{\partial q_o}{\partial t} $$
    %
    % The same derivation applies to the other spatial variables (y, z).
    %
    % This forms a system of equations allowing us to compute the grid velocities:
    %
    % $$ \frac{\partial r_o}{\partial t}, \quad \frac{\partial z_o}{\partial t},
    % \quad \frac{\partial q_o}{\partial t}$$
    %
    % These are named symbolically _dr0dt_, _dz0dt_, and _dq0dt_.
    %
    syms dr0dt  dz0dt  dq0dt real
    x=X(1);
    y=X(2);
    z=X(3);
    eqn1 = diff(x,t0) +diff(x,z0)*dz0dt +diff(x,r0)*dr0dt+diff(x,q0)*dq0dt==0;
    eqn2 = diff(y,t0) +diff(y,z0)*dz0dt +diff(y,r0)*dr0dt+diff(y,q0)*dq0dt==0;
    eqn3 = diff(z,t0) +diff(z,z0)*dz0dt +diff(z,r0)*dr0dt+diff(z,q0)*dq0dt==0;
    [Aeqn,Beqn]=equationsToMatrix([eqn1,eqn2,eqn3],[dr0dt,dz0dt,dq0dt]);
    Xeqn=linsolve(Aeqn,Beqn);
    dr0dt=simplify(Xeqn(1));
    dz0dt=simplify(Xeqn(2));
    dq0dt=simplify(Xeqn(3));
    %%
    % Derivatives in the physical space can be expressed in terms of
    % derivatives in the mapped space using the inverse Jacobian (Jinv)
    % calculated earlier.
    for j = 1:NVAR(kk)
        var_name = sprintf('%s%d', list_var{kk}{j},kk);
        % First derivatives in X
        eval(sprintf('d%sdy = Jinv(1, 1) * diff(%s, xs(1)) + Jinv(2, 1) * diff(%s, xs(2))+ Jinv(3, 1) * diff(%s, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdx = Jinv(1, 2) * diff(%s, xs(1)) + Jinv(2, 2) * diff(%s, xs(2))+ Jinv(3, 2) * diff(%s, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdz = Jinv(1, 3) * diff(%s, xs(1)) + Jinv(2, 3) * diff(%s, xs(2))+ Jinv(3, 3) * diff(%s, xs(3));', var_name, var_name, var_name,var_name));
        %%
        %Similarly, time derivative would be: 
        eval(sprintf('d%sdt = diff(%s,t0)+diff(%s,r0)*dr0dt+diff(%s,z0)*dz0dt+diff(%s,q0)*dq0dt;', var_name, var_name, var_name,var_name,var_name));
        %% 
        % Second-order derivatives in physical coordinates are obtained 
        % using the chain rule again:
        eval(sprintf('d%sdyy = Jinv(1, 1) * diff(d%sdy, xs(1)) + Jinv(2, 1) * diff(d%sdy, xs(2))+ Jinv(3, 1) * diff(d%sdy, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdxx = Jinv(1, 2) * diff(d%sdx, xs(1)) + Jinv(2, 2) * diff(d%sdx, xs(2))+ Jinv(3, 2) * diff(d%sdx, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdzz = Jinv(1, 3) * diff(d%sdz, xs(1)) + Jinv(2, 3) * diff(d%sdz, xs(2))+ Jinv(3, 3) * diff(d%sdz, xs(3));', var_name, var_name, var_name,var_name));
        %%
        % Derivatives in the mapped space are straightforward:
        eval(sprintf('d%sdr0 = diff(%s, r0);', var_name, var_name));
        eval(sprintf('d%sdz0 = diff(%s, z0);', var_name, var_name));
        eval(sprintf('d%sdrr0 = diff(%s, r0, r0);', var_name, var_name));
        eval(sprintf('d%sdzz0 = diff(%s, z0, z0);', var_name, var_name));
        eval(sprintf('d%sdrz0 = diff(%s, r0, z0);', var_name, var_name));
        eval(sprintf('d%sdt0 = diff(%s, t0);', var_name, var_name));
    end
    %% Auxiliary Variables
    % In some cases, it's convenient to use auxiliary variables, such as
    % the velocity vector in Cartesian coordinates:
    %
    % $$ \mathbf{V} = v_y \mathbf{e_y} + v_x \mathbf{e_x} + v_z \mathbf{e_z} $$
    % Note: Assuming standard Cartesian (x,y,z) although code uses (y,x,z) based on F0, G0.
    
    V=vy0*bbase{1}+vx0*bbase{2}+0*bbase{3};
    %%
    % If derivatives of auxiliary variables appear in the equations,
    % the same differentiation procedure described above would be repeated 
    % for them.
    list_aux={'V','p0', 'F0', 'G0'};
    for j = 1:length(list_aux)
        var_name = sprintf('%s', list_aux{j});
        % First derivatives in physical space (using the same logic as before)
        eval(sprintf('d%sdy = Jinv(1, 1) * diff(%s, xs(1)) + Jinv(2, 1) * diff(%s, xs(2))+ Jinv(3, 1) * diff(%s, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdx = Jinv(1, 2) * diff(%s, xs(1)) + Jinv(2, 2) * diff(%s, xs(2))+ Jinv(3, 2) * diff(%s, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdz = Jinv(1, 3) * diff(%s, xs(1)) + Jinv(2, 3) * diff(%s, xs(2))+ Jinv(3, 3) * diff(%s, xs(3));', var_name, var_name, var_name,var_name));
        %%
        %Time derivative:
        eval(sprintf('d%sdt = diff(%s,t0)+diff(%s,r0)*dr0dt+diff(%s,z0)*dz0dt+diff(%s,q0)*dq0dt;', var_name, var_name, var_name,var_name,var_name));
        %%
        % Second order derivatives:
        eval(sprintf('d%sdyy = Jinv(1, 1) * diff(d%sdy, xs(1)) + Jinv(2, 1) * diff(d%sdy, xs(2))+ Jinv(3, 1) * diff(d%sdy, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdxx = Jinv(1, 2) * diff(d%sdx, xs(1)) + Jinv(2, 2) * diff(d%sdx, xs(2))+ Jinv(3, 2) * diff(d%sdx, xs(3));', var_name, var_name, var_name,var_name));
        eval(sprintf('d%sdzz = Jinv(1, 3) * diff(d%sdz, xs(1)) + Jinv(2, 3) * diff(d%sdz, xs(2))+ Jinv(3, 3) * diff(d%sdz, xs(3));', var_name, var_name, var_name,var_name));
        %%
        % Derivatives in mapped space:
        eval(sprintf('d%sdr0 = diff(%s, r0);', var_name, var_name));
        eval(sprintf('d%sdz0 = diff(%s, z0);', var_name, var_name));
        eval(sprintf('d%sdrr0 = diff(%s, r0, r0);', var_name, var_name));
        eval(sprintf('d%sdzz0 = diff(%s, z0, z0);', var_name, var_name));
        eval(sprintf('d%sdrz0 = diff(%s, r0, z0);', var_name, var_name));
        eval(sprintf('d%sdt0 = diff(%s, t0);', var_name, var_name));
    end
    %%
    % Setting up auxiliary velocity operators simplifies writing the equations:
    % Examples: Velocity gradient, rate-of-strain tensor, vorticity tensor, convective term.
    %
    % $$ \nabla \mathbf{v}, \: (\nabla \mathbf{v} + \nabla^T \mathbf{v})/2 , \: (\nabla \mathbf{v} - \nabla^T \mathbf{v})/2, , \: \mathbf{v} \cdot \nabla \mathbf{v},...$$
    %
    gradientV=[dVdy.',dVdx.',dVdz.']; %$\nabla \mathbf{v}$ 
    DD=(gradientV+gradientV.')/2; %$(\nabla \mathbf{v} + \nabla^T \mathbf{v})/2$
    WW=(gradientV-gradientV.')/2; %$(\nabla \mathbf{v} - \nabla^T \mathbf{v})/2$
    VnablaV=vx1*zeros(1,3);
    for i=1:3
        VnablaV(i)=simplify(V(1)*dVdy(i)+V(2)*dVdx(i)+V(3)*dVdz(i)); %$\mathbf{v} \dot \nabla \mathbf{v}$
    end
    laplaceV=simplify(dVdxx+dVdyy+dVdzz); %Laplace operator
    gradientP=[dp0dy,dp0dx,dp0dz]; %pressure gradient
    divergencV=simplify(dVdx(2)+dVdy(1)+dVdz(3)); %divergence of the velocity
    %%
    % Also, for the quasi-elliptic transformation mapping from Dimakopoulos & Tsamopoulos (2003),
    % we introduce the following auxiliary functions related to the mesh mapping:
    % F0, G0 likely represent the physical coordinates y, x as functions of mapped r0, z0.
    %
    g11=dG0dz0^2+dF0dz0^2;
    g22=dG0dr0^2+dF0dr0^2;
    g12=dG0dr0*dG0dz0+dF0dr0*dF0dz0;
    JJ=dG0dr0*dF0dz0-dG0dz0*dF0dr0;
    eps1=0.3;
    D1=eps1*((dF0dz0^2+dG0dz0^2)/(dF0dr0^2+dG0dr0^2))^0.5+(1-eps1);
    dD1dr0=diff(D1,r0);
    dD1dz0=diff(D1,z0);
    Q1=-(dD1dr0*dF0dz0-dD1dz0*dF0dr0)*JJ/D1;
    %
    %% Setting the Equations for Each Region
    %
    % Using the auxiliary variables defined above, the governing equations 
    % (e.g., Navier-Stokes) become simpler to write.
    % Example: Dimensionless Momentum equation (assuming incompressible flow)
    MOMENTUM=-(dVdt+VnablaV)-gradientP+laplaceV/Re;
    %%
    % that proyecting in base bc is
    MOMENTUMP=0*MOMENTUM;
    for i=1:3
        MOMENTUMP(i)=(MOMENTUM*(bc{i}.'));
    end
    %2D momentum
    EQ{1,kk}=MOMENTUMP(1); %axial momentum
    EQ{2,kk}=MOMENTUMP(2); %radial mometum
    EQ{3,kk}=divergencV; %conservation
    EQ{4,kk}=g22*dF0dzz0+g11*dF0drr0-2*g12*dF0drz0-Q1; %
    EQ{5,kk}=g22*dG0dzz0+g11*dG0drr0-2*g12*dG0drz0; %
end
%% Setting Up the Full Equation System
% To facilitate numerical implementation and avoid complex indexing for different regions/boundaries,
% unknowns originating in a specific region are formally extended to all other regions.
% Their values (and corresponding equations) outside their original region are set to zero.
% In the conceptual diagram below, these artificially extended 
% unknowns/equations are shown in red.
%
% <html>
% <object type="image/svg+xml" data="equation.svg" width="400" height="300"> </object>
% </html>
%
% Therefore, the equations for these 'ghost' unknowns must enforce that they are zero.
% At each node/location (total Nequations corresponding to different boundary/interior types),
% we define a full array of NVA equations (total number of variables across all regions).
% Only those equations involving unknowns actually present at that location are physically meaningful.
%
% By default, we initialize the equation array at each location to set all NVA variables to zero.
% This handles the 'ghost' variables correctly.
%
% At each location type k (1 to _Nequations_), the full set of equations FFk initially enforces FFk(i) = variable_i = 0 for all i.
for k = 1:Nequations
    eq_name = sprintf('FF%d', k);
    eval(sprintf('%s = sym(zeros(NVA, 1));', eq_name));
    lv=0;
    for j = 1:NRegion
        for i = 1:NVAR(j)
            variable_name = list_var{j}{i}; % Get the variable name
            lv=lv+1;
            eval(sprintf('%s(%d)=%s%d;', eq_name,lv,variable_name,j));
        end
    end
end

%% 
%%
% Now, overwrite the default zero equations with the actual governing equations or boundary conditions
% that apply at each specific location type.
% Location 1: Interior of Region 1
% The first NVAR(1) equations (corresponding to region 1 variables) are replaced.
%
% $$ \begin{array}{llcl}
% F1(1) = 0 = & v_{y1} & \Leftarrow & (\partial_t \mathbf{v}_1 + \mathbf{v}_1 \cdot \nabla \mathbf{v}_1 + \nabla p_1 -\nabla^2 \mathbf{v}_1/Re) \cdot \mathbf{e}_y \\
% F1(2) = 0 = & v_{x1} & \Leftarrow & (\partial_t \mathbf{v}_1 + \mathbf{v}_1 \cdot \nabla \mathbf{v}_1 + \nabla p_1 -\nabla^2 \mathbf{v}_1/Re) \cdot \mathbf{e}_x \\
% F1(3) = 0 = & p_{1} & \Leftarrow &  \nabla \cdot \mathbf{v}_1\\
% F1(4) = 0 = & F_{1} & \Leftarrow  &  ...\\
% F1(5) = 0 = & G_{1} & \Leftarrow &   ...\\
% F1(6) = 0 = & v_{y2} &   & \\
% F1(7) = 0 = & v_{x2} &  & \\
% F1(8) = 0 = & p_{2} &   & \\
% F1(9) = 0 = & F_{2} &   & \\
% F1(10) = 0 = & G_{2} &  & \\
% \end{array} $$
%
FF1(1)=EQ{1,1};
FF1(2)=EQ{2,1};
FF1(3)=EQ{3,1};
FF1(4)=EQ{4,1};
FF1(5)=EQ{5,1};

%%
% Location 2: Interior of Region 2
% Equations corresponding to region 2 variables (indices NVAR(1)+1 to NVA) are replaced.
%
% $$ \begin{array}{llcl}
% F2(1) = 0 = & v_{y1} &   & \\
% F2(2) = 0 = & v_{x1} &  & \\
% F2(3) = 0 = & p_{1} &   & \\
% F2(4) = 0 = & F_{1} &   & \\
% F2(5) = 0 = & G_{1} &  & \\
% F2(6) = 0 = & v_{y2} & \Leftarrow & (\partial_t \mathbf{v}_2 + \mathbf{v}_2 \cdot \nabla \mathbf{v}_2 + \nabla p_2 -\nabla^2 \mathbf{v}_2/Re) \cdot \mathbf{e}_y \\
% F2(7) = 0 = & v_{x2} & \Leftarrow & (\partial_t \mathbf{v}_2 + \mathbf{v}_2 \cdot \nabla \mathbf{v}_2 + \nabla p_2 -\nabla^2 \mathbf{v}_2/Re) \cdot \mathbf{e}_x \\
% F2(8) = 0 = & p_{2} & \Leftarrow  &  \nabla \cdot \mathbf{v}_2\\
% F2(9) = 0 = & F_{2} & \Leftarrow  &  ...\\
% F2(10) = 0 = & G_{2} & \Leftarrow  &   ...\\
% \end{array} $$
%
FF2(6)=EQ{1,2};
FF2(7)=EQ{2,2};
FF2(8)=EQ{3,2};
FF2(9)=EQ{4,2};
FF2(10)=EQ{5,2};

%%
% Location 3: Inlet Boundary (Affects both regions)
% Specify inlet boundary conditions for all variables.
%
% $$ \begin{array}{llcl}
% F3(1) = 0 = & v_{y1} & \Leftarrow  & v_{y1}   \\
% F3(2) = 0 = & v_{x1} & \Leftarrow & v_{x1} -1 \\
% F3(3) = 0 = & p_{1} &  \Leftarrow & \partial_x p_1\\
% F3(4) = 0 = & F_{1} & \Leftarrow  & F_1 -Y_1 \\
% F3(5) = 0 = & G_{1} & \Leftarrow &  G_1 - X_1 \\
% F3(6) = 0 = & v_{y2} & \Leftarrow & v_{y2} \\
% F3(7) = 0 = & v_{x2} & \Leftarrow & v_{x2}-1\\
% F3(8) = 0 = & p_{2} & \Leftarrow  & \partial_x p_2\\
% F3(9) = 0 = & F_{2} & \Leftarrow  & F_2 -Y_2\\
% F3(10) = 0 = & G_{2} & \Leftarrow  & G_2 -X_2\\
% \end{array} $$
%
FF3(1)=vy1;
FF3(2)=vx1-1;
FF3(3)=dp1dx;
FF3(4)=F1-Y1;
FF3(5)=G1-X1;
FF3(6)=vy2;
FF3(7)=vx2-1;
FF3(8)=dp2dx;
FF3(9)=F2-Y2;
FF3(10)=G2-X2;

%%
% Location 4: Outlet Boundary (Affects both regions)
% Specify outlet boundary conditions.
%
% $$ \begin{array}{llcl}
% F4(1) = 0 = & v_{y1} & \Leftarrow  & v_{y1}   \\
% F4(2) = 0 = & v_{x1} & \Leftarrow & v_{x1} -1 \\
% F4(3) = 0 = & p_{1} &  \Leftarrow & p_1\\
% F4(4) = 0 = & F_{1} & \Leftarrow  & F_1 -Y_1 \\
% F4(5) = 0 = & G_{1} & \Leftarrow &  G_1 - X_1 \\
% F4(6) = 0 = & v_{y2} & \Leftarrow & v_{y2} \\
% F4(7) = 0 = & v_{x2} & \Leftarrow & v_{x2}-1\\
% F4(8) = 0 = & p_{2} & \Leftarrow  & p_2\\
% F4(9) = 0 = & F_{2} & \Leftarrow  & F_2 -Y_2\\
% F4(10) = 0 = & G_{2} & \Leftarrow  & G_2 -X_2\\
% \end{array} $$
%
FF4(1)=vy1;
FF4(2)=dvx1dx;
FF4(3)=p1;
FF4(4)=F1-Y1;
FF4(5)=G1-X1;
FF4(6)=vy2;
FF4(7)=dvx2dx;
FF4(8)=p2;
FF4(9)=F2-Y2;
FF4(10)=G2-X2;

%%
% Location 5: Interface between Region 1 and Region 2
% Impose continuity of velocity, normal stress, and mesh position.
% Assuming y-direction is normal to the interface.
%
% $$ \begin{array}{llcl}
% F5(1) = 0 = & v_{y1} & \Leftarrow  & v_{y1} - v_{y2}  \\
% F5(2) = 0 = & v_{x1} & \Leftarrow &  v_{x1} - v_{x2} \\
% F5(3) = 0 = & p_{1} &  \Leftarrow & p_1 -p_2\\
% F5(4) = 0 = & F_{1} & \Leftarrow  & F_1 -Y_1 \\
% F5(5) = 0 = & G_{1} & \Leftarrow &  G_1 -X_1 \\
% F5(6) = 0 = & v_{y2} & \Leftarrow & \partial_y v_{y1} - \partial_y v_{y2} \\
% F5(7) = 0 = & v_{x2} & \Leftarrow & \partial_y v_{x1} - \partial_y v_{x2}\\
% F5(8) = 0 = & p_{2} & \Leftarrow  & \partial_y p_1 -\partial_y p_2\\
% F5(9) = 0 = & F_{2} & \Leftarrow  & F_2 -Y_2\\
% F5(10) = 0 = & G_{2} & \Leftarrow  & G_2 -X_2\\
% \end{array} $$
%
FF5(1)=vy1-vy2;
FF5(2)=vx1-vx2;
FF5(3)=p1-p2;
FF5(4)=F1-Y1;
FF5(5)=G1-X1;
FF5(6)=dvy1dy-dvy2dy;
FF5(7)=dvx1dy-dvx2dy;
FF5(8)=dp1dy-dp2dy;
FF5(9)=F2-Y2;
FF5(10)=G2-X2;

%%
% Location 6: Bottom boundary.
%
% $$ \begin{array}{llcl}
% F6(1) = 0 = & v_{y1} & \Leftarrow  & v_{y1}   \\
% F6(2) = 0 = & v_{x1} & \Leftarrow & \partial_y v_{x1} \\
% F6(3) = 0 = & p_{1} &  \Leftarrow & \partial_y p_1\\
% F6(4) = 0 = & F_{1} & \Leftarrow  & F_1 -Y_1 \\
% F6(5) = 0 = & G_{1} & \Leftarrow &  \partial_{z_o z_o} G_1\\
% F6(6) = 0 = & v_{y2} &  & \\
% F6(7) = 0 = & v_{x2} &  & \\
% F6(8) = 0 = & p_{2} &   & \\
% F6(9) = 0 = & F_{2} &   & \\
% F6(10) = 0 = & G_{2} &  & \\
% \end{array} $$
%
FF6(1)=vy1;
FF6(2)=dvx1dy;
FF6(3)=dp1dy;
FF6(4)=F1-Y1;
FF6(5)=dG1dzz0;

%%
% Location 7: Top Boundary
% Similar to Location 6, but applies only to Region 2 variables.
%
% $$ \begin{array}{llcl}
% F7(1) = 0 = & v_{y1} &   & \\
% F7(2) = 0 = & v_{x1} &  &  \\
% F7(3) = 0 = & p_{1} &   &  \\
% F7(4) = 0 = & F_{1} &   &  \\
% F7(5) = 0 = & G_{1} &  &   \\
% F7(6) = 0 = & v_{y2} & \Leftarrow & v_{y2} \\
% F7(7) = 0 = & v_{x2} & \Leftarrow & \partial_y v_{x2}\\
% F7(8) = 0 = & p_{2} & \Leftarrow  & \partial_y p_2\\
% F7(9) = 0 = & F_{2} & \Leftarrow  & F_2 -Y_2\\
% F7(10) = 0 = & G_{2} & \Leftarrow  & \partial_{z_o z_o} G_2\\
% \end{array} $$
%
FF7(6)=vy2;
FF7(7)=dvx2dy;
FF7(8)=dp2dy;
FF7(9)=F2-Y2;
FF7(10)=dG2dzz0;

%%
% Location 8: Cylinder Surface Boundary (Affects both regions if interface)
% Example: No-slip cylinder wall, fixed position. Normal direction is likely r0.
%
% $$ \begin{array}{llcl}
% F8(1) = 0 = & v_{y1} & \Leftarrow  & v_{y1}   \\
% F8(2) = 0 = & v_{x1} & \Leftarrow & v_{x1} \\
% F8(3) = 0 = & p_{1} &  \Leftarrow & \partial_{n} p_1\\
% F8(4) = 0 = & F_{1} & \Leftarrow  & F_1 -Y_1 \\
% F8(5) = 0 = & G_{1} & \Leftarrow &  G_1 - X_1 \\
% F8(6) = 0 = & v_{y2} & \Leftarrow & v_{y2} \\
% F8(7) = 0 = & v_{x2} & \Leftarrow & v_{x2}\\
% F8(8) = 0 = & p_{2} & \Leftarrow  & \partial_n p_2\\
% F8(9) = 0 = & F_{2} & \Leftarrow  & F_2 -Y_2\\
% F8(10) = 0 = & G_{2} & \Leftarrow  & F_2 -X_2\\
% \end{array} $$
%
FF8(1)=vy1;
FF8(2)=vx1;
FF8(3)=dp1dr0; % r0 is the normal
FF8(4)=F1-Y1;
FF8(5)=G1-X1;
FF8(6)=vy2;
FF8(7)=vx2;
FF8(8)=dp2dr0; % r0 is the normal
FF8(9)=F2-Y2;
FF8(10)=G2-X2;

%% Preparations for the numerical evaluation
% Once the symbolic equations (FF1, FF2, ..., FF8) are defined, it's more practical
% for numerical evaluation to substitute symbolic variable names and their derivatives
% with indexed array names.
% Example: The pressure in region 1 (p1), which is the 3rd variable (v=3) in region 1 (k=1)
% with no derivatives (d=1), will be substituted by yb1v3d1.
%
% $$ p_1 \Leftrightarrow yb1v3d1 $$
%
% Similarly, the second derivative of G (5th variable, v=5) in region 2 (k=2)
% with respect to z0 (assuming this corresponds to the 5th derivative index, d=5)
% would be represented as yb2v5d5.
%
% $$ \frac{\partial^2 G_2}{\partial z_o^2} \Leftrightarrow yb2v5d5 $$
% 
% First, create symbolic arrays for the numerical variables (yF) and the corresponding
% symbolic expressions involving base variables and derivatives (yFsym).
yFF=cell(1,NRegion);  %Will be the real variable
yFFsym=cell(1,NRegion); % symbolic matrix
for kk=1:NRegion
    yFF{kk} = sym('yF', [NVAR(kk), NDA], 'real'); % Preallocating symbolic array
    yFFsym{kk} = sym('yFsym', [NVAR(kk), NDA], 'real');
    for l = 1:NVAR(kk)
        for k = 1:NDA  % Derivatives
            yFF{kk}(l, k) = sym(['yb', num2str(kk), 'v', num2str(l), 'd', num2str(k)], 'real');
            if k == 1
                name = sprintf('yFFsym{kk}(l, 1) = %s%d;', list_var{kk}{l},kk);
            else
                name = sprintf('yFFsym{kk}(l, %d) = diff(%s%d%s;', k, list_var{kk}{l},kk, list_dersymbolic{k});
            end
            eval(name);
        end
    end
end
yFsym = vertcat(yFFsym{:});
yF = vertcat(yFF{:});

%%
% Perform the substitution in the previously defined equation sets (FF1, ..., FF8)
% Replace the symbolic expressions (like p1, diff(G2,z0,z0)) with their numerical placeholders (yb1v3d1, yb2v5d5).
% Substitution is done from highest order derivatives to lowest to ensure correctness.
for le = 1:Nequations
    eq_name = sprintf('FF%d', le);
    eval(sprintf('Eq = %s;', eq_name));
    k = 1:NVA;
    i = NDA:-1:1;
    Eq = subs(Eq, yFsym(k, i), yF(k, i));

    %%
    % Because 2D we force q0=0 in all the equations in order to simplify
    Eq = subs(Eq, q0, 0);
    eval(sprintf('%s = Eq;', eq_name));
end

%% Generate MATLAB functions for the equations and their Jacobians
% The final step is to convert the symbolic equations (now in terms of placeholders ybKvLdM)
% and their Jacobians into efficient MATLAB function files for numerical solving.

% Reshape the numerical placeholder matrix yF into a single column vector 'x'.
% This represents the vector of unknowns that the numerical solver will handle.
x = reshape(yF', NVA * NDA, 1); % Variables and derivatives
for i = 1:Nequations
    eq_name = sprintf('FF%d', i);
    dFF_name = sprintf('dFF%d', i);
    eval(sprintf('%s = sym(zeros(NVA, NVA * NDA));', dFF_name));
    k = 1:NVA;
    eval(sprintf('%s(k, :) = jacobian(%s(k), x);', dFF_name, eq_name));
    file_name = sprintf('%sequationF%d', pathequation, i);
    eval(sprintf('matlabFunction(%s, %s, ''File'', ''%s'', ''Vars'', {z0, r0, x, pa});', eq_name, dFF_name, file_name));
end



##### SOURCE END #####
--></body></html>