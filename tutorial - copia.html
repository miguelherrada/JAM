<!DOCTYPE html>
<html lang="en">
<head>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JAM Tutorial</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" 
          rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" 
          rel="stylesheet" />
    <link rel="stylesheet" 
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { padding-top: 70px; background-color: #f8f9fa; }
        h1 { color: #007acc; }
        h2 { color: #005f99; }
        a.btn { margin-top: 20px; }
        .ref-link { color: #3498db; text-decoration: underline; }
        /* Estilos para el contenido de Matlab */
        .matlab-content { font-size:1.2em; line-height:140%; padding: 20px; }
        .matlab-content h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
        .matlab-content h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
        .matlab-content h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }
        .matlab-content a { color:#005fce; text-decoration:none; }
        .matlab-content a:hover { color:#005fce; text-decoration:underline; }
        .matlab-content a:visited { color:#004aa0; text-decoration:none; }
        .matlab-content p { padding:0px; margin:0px 0px 20px; }
        .matlab-content ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
        .matlab-content ul li { padding:0px; margin:0px 0px 7px 0px; }
        .matlab-content ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
        .matlab-content pre, .matlab-content code { font-size:12px; }
        .matlab-content pre { margin:0px 0px 20px; }
        .matlab-content pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
        .matlab-content pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
        .matlab-content pre.error { color:red; }
        .matlab-content span.keyword { color:#0000FF; }
        .matlab-content span.comment { color:#228B22; }
        .matlab-content span.string { color:#A020F0; }
        .matlab-content span.untermstring { color:#B20000; }
        .matlab-content span.syscmd { color:#B28C00; }
        .matlab-content span.typesection { color:#A0522D; }
        .matlab-content .footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
        .matlab-content .footer p { margin:0px; }
        .matlab-content .footer a { color:#878787; }
        .matlab-content .footer a:hover { color:#878787; text-decoration:underline; }
        .matlab-content .footer a:visited { color:#878787; }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top">
        <div class="container">
            <a class="navbar-brand" href="index.html">
                <img src="logo.png" alt="JAM Logo" width="100">
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" 
                    data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" 
                    aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="tutorial.html">Tutorial</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="https://github.com/miguelherrada/JAM" 
                           target="_blank">GitHub</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="JAM.pdf" target="_blank">Paper</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Tutorial Content -->
    <div class="container">
        <h1 class="mt-4">Welcome to the JAM Tutorial</h1>
        <p class="lead">
            This tutorial provides a comprehensive, step-by-step explanation of the JAM code’s 
            functionality. You’ll need Matlab or a Python compiler installed to run or modify 
            the examples.
        </p>

        <div class="card mb-4">
            <div class="card-body">
                <h2 class="card-title">Contents</h2>
                <ul class="list-group list-group-flush">
                    <li class="list-group-item">
                        <a href="#introduction">
                            <i class="fas fa-book"></i> Introduction to JAM
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="#setup">
                            <i class="fas fa-cogs"></i> Setting up the Environment
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="#examples">
                            <i class="fas fa-code"></i> Experimenting with the Examples
                        </a>
                    </li>
                    <li class="list-group-item">
                        <a href="#steps">
                            <i class="fas fa-code"></i> Solving a problem with JAM step-by-step
                        </a>
                    </li>
                </ul>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-body">
                <h2 id="introduction" class="card-title">Introduction to JAM</h2>
                <p>
                    The Jacobian Analytical Method (JAM) is an advanced computational framework 
                    designed to efficiently solve complex non-linear problems, particularly those 
                    involving flows with free interfaces or moving boundaries. Originally developed 
                    by <a href="bibliography.html#ref2016" class="ref-link">
                    Herrada and Montanero (2016)</a>, JAM stands out for its ability to map intricate 
                    physical domains to rectangular spaces via non-singular transformations, 
                    simplifying both non-linear analysis and linear stability studies of capillary 
                    systems and other fluid dynamics problems.
                </p>
                <p>What makes JAM unique is its focus on the symbolic computation of analytical Jacobians, eliminating the need for costly numerical approximations or the traditional use of Christoffel symbols to handle curvature in non-Euclidean spaces. This approach, refined in a recent work (<a href="bibliography.html#ref2024" class="ref-link">Herrada, 2024</a>), allows physical laws to be applied directly in Cartesian coordinates, even in curved domains, enhancing accuracy and reducing computational time.</p>
                <p>Key features of JAM include:</p>
                <ul class="list-group list-group-flush">
                    <li class="list-group-item"><strong>Analytical Jacobian Computation:</strong> Utilizes symbolic tools to derive Jacobians with high precision, minimizing numerical errors.</li>
                    <li class="list-group-item"><strong>Computational Optimization:</strong> Combines sparse collocation matrices with analytical Jacobians to assemble the numerical Jacobian matrix, speeding up Newton-Raphson iterations.</li>
                    <li class="list-group-item"><strong>Extreme Flexibility:</strong> Enables the construction of generalized eigenvalue problems to study the global stability of non-linear systems, adapting to diverse applications from capillary fluids to viscoelasticity.</li>
                    <li class="list-group-item"><strong>Avoids Christoffel Symbols:</strong> Simplifies formulation in curved spaces by projecting equations into Euclidean space, easing implementation and scalability.</li>
                </ul>
                <p>JAM is particularly valuable in fields like fluid dynamics, where problems with free interfaces—such as liquid bridges, gravitational jets, or the breakup of viscoelastic threads—demand high precision and efficiency. Through this tutorial, you will learn how to implement JAM in Matlab or Python using practical examples available in the <a href="https://github.com/miguelherrada/JAM">JAM GitHub repository</a>. Get ready to discover a powerful tool that will transform your approach to numerical simulation!</p>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-body">
                <h2 id="setup" class="card-title">Setting up the Environment</h2>
                <p>
                    To run the JAM examples, you need to set up your environment with either Matlab 
                    or Python. Below are detailed instructions for installing and configuring both 
                    options, including the necessary dependencies.
                </p>
        
                <h3>Matlab Setup</h3>
                <p>Matlab requires a valid license to use. If you don’t have Matlab installed, follow these steps:</p>
                <ol>
                    <li>Download and install Matlab from the official MathWorks website: <a href="https://www.mathworks.com/products/matlab.html" target="_blank">https://www.mathworks.com/products/matlab.html</a>.</li>
                    <li>During installation, ensure you include the following toolboxes:
                        <ul>
                            <li><strong>Symbolic Math Toolbox</strong> – Required for symbolic computation in JAM.</li>
                            <li><strong>Optimization Toolbox</strong> – Essential for optimization tasks in JAM examples.</li>
                        </ul>
                    </li>
                    <li>After installation, verify that these toolboxes are enabled. You can check this in Matlab by navigating to "Home" > "Add-Ons" > "Manage Add-Ons".</li>
                </ol>
                
                <h3>Python Setup</h3>
                <p>Python is a free, open-source alternative to Matlab. Below are instructions for installing Python, an IDE, and the required libraries on Windows 11 and Ubuntu.</p>
        
                <h4>Windows 11</h4>
                <ol>
                    <li><strong>Install Python:</strong>
                        <ul>
                            <li>Download the latest stable version of Python from <a href="https://www.python.org/downloads/" target="_blank">https://www.python.org/downloads/</a>.</li>
                            <li>Run the installer and ensure you check the box labeled "Add Python to PATH" to make Python accessible from the command line.</li>
                            <li>Complete the installation by following the on-screen instructions.</li>
                        </ul>
                    </li>
                    <li><strong>Install Visual Studio Code (IDE):</strong>
                        <ul>
                            <li>Download Visual Studio Code from <a href="https://code.visualstudio.com/" target="_blank">https://code.visualstudio.com/</a>.</li>
                            <li>Run the installer and follow the prompts to complete the installation.</li>
                            <li>Open Visual Studio Code, go to the Extensions view (Ctrl+Shift+X), search for "Python", and install the official Python extension by Microsoft.</li>
                        </ul>
                    </li>
                    <li><strong>Install Required Libraries:</strong>
                        <ul>
                            <li>Open a terminal in Visual Studio Code (Terminal > New Terminal) or use the Command Prompt.</li>
                            <li>Run the following command to install the necessary libraries:
                                <pre><code>pip install numpy sympy scipy matplotlib</code></pre>
                            </li>
                        </ul>
                    </li>
                </ol>
        
                <h4>Ubuntu</h4>
                <ol>
                    <li><strong>Install Python:</strong>
                        <ul>
                            <li>Open a terminal and run the following commands to update your system and install Python along with pip:
                                <pre><code>sudo apt update
sudo apt install python3 python3-pip</code></pre>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Install Visual Studio Code (IDE):</strong>
                        <ul>
                            <li>Visual Studio Code is available on Ubuntu via the Snap package manager. Install it by running:
                                <pre><code>sudo snap install --classic code</code></pre>
                            </li>
                            <li>Open Visual Studio Code, go to the Extensions view (Ctrl+Shift+X), search for "Python", and install the official Python extension by Microsoft.</li>
                            <li><strong>Alternative:</strong> If you prefer another IDE, you can install PyCharm Community Edition with:
                                <pre><code>sudo snap install pycharm-community --classic</code></pre>
                            </li>
                        </ul>
                    </li>
                    <li><strong>Install Required Libraries:</strong>
                        <ul>
                            <li>In the terminal, run the following command to install the necessary libraries:
                                <pre><code>pip3 install numpy sympy scipy matplotlib</code></pre>
                            </li>
                        </ul>
                    </li>
                </ol>
        
                <p>With Matlab or Python set up as described above, you’ll have all the tools and dependencies needed to run the JAM examples from the <a href="https://github.com/miguelherrada/JAM">GitHub repository</a>.</p>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-body">
                <h2 id="examples" class="card-title">Experimenting with the Examples</h2>
                <p>
                    To test the examples contained in the repository, you simply need to download 
                    them to your local directory. If you want to test an example in MATLAB, download 
                    the "Matlab" directory, open MATLAB, and navigate to the desired directory. For 
                    instance, you could go to the "elbow" directory. In JAM, the main program always 
                    starts with "Main". In this case, you would run the program 
                    <a href="Mainelbow3D.html" target="_blank">Mainelbow3D.m</a>. To run the same 
                    example in Python, download the "Python" directory to your computer and navigate 
                    to "elbow". Open your Python compiler (e.g., "Visual Studio Code") and execute 
                    the main file "Mainelbow3D.py". The symbolic functions required to assemble the 
                    numerical Jacobian are already generated and stored in the "Jacobians" directory 
                    of each example. The symbolic computation is performed by running the JAM 
                    function that always begins with "blockA". To see how these functions are 
                    generated, for MATLAB, you would run 
                    <a href="blockAcartesianvelocity.html" 
                       target="_blank">
                       blockAcartesianvelocity.m
                    </a>, and for Python, "blockAelbow.py". The collocation 
                    matrices corresponding to the different types of discretizations that can be 
                    applied with JAM are located in the "utils/collocationmatrices" folder of the 
                    main directory.
                </p>
            </div>
        </div>

        <div class="card mb-4">
            <div class="card-body">
                <h2 id="steps" class="card-title">Solving a problem with JAM step-by-step</h2>
                
                <h3><span style="color: green;">2D Flow Around a Cylinder</span></h3>
                <p>As an example, we will solve the 2D flow of a liquid (incompressible fluid) with density \(\rho\) and viscosity \(\eta\) around a cylinder of radius \(R\), 
                    approaching from the left with a uniform velocity \(U\), and with the coordinate system \((x, y)\) originating at the center of the cylinder
                     (see <a href="#figure1">Figure 1</a>). If we use \(U, \rho\), and \(R\) for nondimensionalization as characteristic magnitude the dimensionless equations for the bulk (regions [1] and [2] in the figure) are </p>

<ul>
    <li><strong>Continuity equation:</strong></li>
    <p>\[\nabla \cdot \mathbf{V} = 0\]</p>
    <li><strong>Momentum equation:</strong></li>
    <p>\[\mathbf{M}_{\mathbf{X}} = \left( \frac{\partial \mathbf{V}}{\partial t} + (\mathbf{V} \cdot \nabla) \mathbf{V} \right) + \nabla p - \frac{1}{Re} \nabla^2 \mathbf{V} = \mathbf{0}\]</p>
</ul>
<p>where, \(Re = \frac{\rho U R}{\mu}\) is the Reynolds number and all operators and vectors are written in the Cartesian system \(\mathbf{X}\).
                
                <p>Our computational domain in the physical bidimensional space will be a rectangle \([-6 \times 16] \times [-6 \times 6]\) with the cylinder at the center.
                     To map this domain to a rectangle \([0 \times 1] \times [-1 \times 1]\) in the transformed space \((z_0, r_0)\), we will apply two non-singular transformations
                      between the upper/lower parts of the physical domain (red/green) and the upper/lower parts of our numerical "box" (see lines 157-171 in <a href="BlockA.html" target="_blank">BlockA.m</a>).</p>
                
                <p>The \(z_0\) coordinate is discretized using \(nz\) finite differences of \(2^{(nd)}\) order (<a href="finites2thsparse.html" target="_blank">finites2thsparse.m</a> function), while the \(r_0\) coordinates of the lower block and the upper block are discretized using Chebyshev polynomials with a stretching function controlled by parameter \(\alpha\) using <a href="chevitanh.html" target="_blank">chevitanh.m</a> and <a href="chevitanh_inverse.html" target="_blank">chevitanh_inverse.m</a>.</p>
            
                
                <p>The resulting collocation matrices are discretizations in one dimension (\(z_0\) or \(r_0\)). One of the keys to applying the method is to extend these matrices to two or three dimensions. In our case, the 1D matrices are extended to 2D using the 'kron' command. The full 2D collocation matrices for each block are generated using the function <a href="collocationmatrices2th.html" target="_blank">collocationmatrices2th.m</a>.</p>
                
                <p>In order to obtain the eight variables in our discretized mesh, it is necessary to consider the lower block, for which four variables are required (\(vy_1, vx_1, p_1, F_1, G_1\)), and the upper block, for which four variables are required (\(vy_2, vx_2, p_2, F_2, G_2\)). In this case, \(vy\) denotes the velocity in the \(y\)-direction, \(vx\) the velocity in the \(x\)-direction, \(p\) denotes the \(y\)-position of the mesh points in the physical domain, and \(G\) denotes the \(x\)-position.</p>
                
                <p>The variables contained within block 1(2) are defined exclusively within the green (red) dots in the box. The definition of both blocks of variables 
                    occurs solely at the connection points of the domains. The complete vector of unknowns, \(x_0\), resulting from the discretization of all unknowns, 
                    is initialized using the function <a href="redeabletoxooptima.html" target="_blank">redeabletoxooptima.m</a>. This function also initializes the auxiliary function \(x_{ofull}\), which is an extension to all the points of the box (it takes as zero the variables that are not defined at the point).</p>
                
                <p>As illustrated in  <a href="#figure1">Figure 1</a>, eight different equations will be used depending on the position within the designated box: 1 and 2 (bulk), 3 (inlet), 4 (outlet), 5 (coupling between blocks 1 and 2), 6 (bottom wall), 7 (top wall), and 8 (cylinder wall).
                     Within the function <a href="pointers6.html" target="_blank">pointers6.m</a>, a pointer “ndA” is generated, which assigns the equation number to the spatial point and generates projection matrices between the box and subdomains 1 and 2 (PNM and PMN).
                      The equations that are solved for each case are found in the <a href="BlockA.html" target="_blank">BlockA.m</a> function. 
                      These include the elliptic mappings for the bulk, mass and momentum conservation equations, and the boundary equations.
                      The 'BlockA' function contains all the symbolic development necessary to generate the analytical functions we will need to assemble the Jacobian matrix in the
                      <a href="matrixAB.html" target="_blank">matrixAB.m</a> function.</p>
                
                <figure id="figure1" class="text-center">
                    <img src="figure1.png" alt="Numerical domain in physical and transformed space" class="img-fluid" style="max-width: 80%;">
                    <figcaption>Figure 1: (a) Numerical domain in physical space \((x, y)\), and (b) its corresponding numerical domain in the transformed space \((z_0, r_0)\), the "box".</figcaption>
                </figure>
                
                <p>The main code that allows us to obtain a stationary solution is Maincylinder.m, which is detailed below.</p>
            </div>
        </div>

        <!-- Contenido de Maincylinder.html -->
        <div class="matlab-content">
            <h1>Maincylinder.m</h1>
            <!--introduction-->
            <!--/introduction-->
            <h2>Contents</h2>
            <div>
                <ul>
                    <li><a href="#1">Initial Setup</a></li>
                    <li><a href="#2">Problem Configuration</a></li>
                    <li><a href="#3">Derivative Definitions</a></li>
                    <li><a href="#4">Compute symbolic functions</a></li>
                    <li><a href="#5">Domain Discretization</a></li>
                    <li><a href="#6">Equation Pointers and Projection Matrices</a></li>
                    <li><a href="#7">Variable Initialization</a></li>
                    <li><a href="#8">Physical Grid Generation</a></li>
                    <li><a href="#9">Full Variable Expansion</a></li>
                    <li><a href="#10">Simulation Parameters</a></li>
                    <li><a href="#11">Time Integration</a></li>
                    <li><a href="#12">Visualization</a></li>
                </ul>
            </div>
            <h2 id="1">Initial Setup</h2>
            <pre class="codeinput">clear <span class="string">all</span>; <span class="comment">% Clear workspace</span>
restoredefaultpath; <span class="comment">% Restore default MATLAB paths</span>
path_jacobian = [<span class="string">'eigen/jacobians/'</span>];<span class="comment">%Symbolic equations</span>
addpath([pwd <span class="string">'/eigen/jacobians/'</span>]); <span class="comment">% Path for Jacobian functions</span>
addpath(<span class="string">'../utils/collocationmatrices/'</span>); <span class="comment">% Path for collocation matrices</span>
</pre>
            <h2 id="2">Problem Configuration</h2>
            <pre class="codeinput">Np = 8; <span class="comment">% Number of dimensionless parameters</span>
Nblock = 2; <span class="comment">% Number of domain blocks (lower and upper)</span>
list_var{1} = {<span class="string">'vy'</span>, <span class="string">'vx'</span>, <span class="string">'p'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>}; <span class="comment">% Variables in block 1 (lower: y&lt;0)</span>
list_var{2} = {<span class="string">'vy'</span>, <span class="string">'vx'</span>, <span class="string">'p'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>}; <span class="comment">% Variables in block 2 (upper: y&gt;0)</span>
list_varA = cat(2, list_var{:}); <span class="comment">% All variables combined</span>
NVAR = cellfun(@length, list_var); <span class="comment">% Number of variables per block</span>
NVA = length(list_varA); <span class="comment">% Total number of variables</span>
</pre>
            <h2 id="3">Derivative Definitions</h2>
            <pre class="codeinput">list_der0 = {<span class="string">''</span>, <span class="string">'r0'</span>, <span class="string">'z0'</span>, <span class="string">'rr0'</span>, <span class="string">'zz0'</span>, <span class="string">'rz0'</span>, <span class="string">'time0'</span>}; <span class="comment">% Derivative types</span>
list_dersymbolic = {<span class="string">''</span>, <span class="string">',r0)'</span>, <span class="string">',z0)'</span>, <span class="string">',r0,r0)'</span>, <span class="string">',z0,z0)'</span>, <span class="string">',z0,r0)'</span> <span class="string">',time)'</span> };
NDA = length(list_der0); <span class="comment">% Number of derivatives</span>
Nequations = 8; <span class="comment">% Number of equation types in the domain</span>
</pre>
            <h2 id="4">Compute symbolic functions</h2>
            <pre class="codeinput">leq=0; <span class="comment">%compiling</span>
<span class="keyword">if</span> (leq==1)

    <span class="keyword">for</span> i=1:Np
    pa(i,1)=sym([<span class="string">'pa_'</span>,num2str(i)],<span class="string">'real'</span>);
    <span class="keyword">end</span>
    Re=pa(1)  <span class="comment">% Reynolds numbers based on the Radius</span>
  Rout=pa(2)  <span class="comment">% y=+-Rout: top-bottom y-posion of the 2D domain</span>
    L1=pa(3); <span class="comment">% x=-L1: left x-position of the 2D domain</span>
    L2=pa(4); <span class="comment">% x=+L2: right x-position of the 2D domain</span>
    Y1=pa(5); <span class="comment">% y-boder for domain 1</span>
    X1=pa(6); <span class="comment">% x-boder for domain 1</span>
    Y2=pa(7); <span class="comment">% y-boder for domain 2</span>
    X2=pa(8); <span class="comment">% x-boder for domain 2</span>
    <span class="comment">%Compiling symbolic equations</span>
    blockA;
<span class="keyword">end</span>
</pre>
            <h2 id="5">Domain Discretization</h2>
            <pre class="codeinput">nr = [17, 17]; <span class="comment">% Radial points per block (lower, upper)</span>
nz = [801, 801]; <span class="comment">% Axial points per block (must be multiple of 4 + 1)</span>
alphar = 3; <span class="comment">% Radial stretching parameter</span>
[r0A, z0A, nrA, nzA, ddr0A, ddrr0A, ddz0A, ddzz0A, Ia, Ib, Ja, Jb] = <span class="keyword">...</span>
    collocationmatrices2th(nr, nz, Nblock, alphar); <span class="comment">% Generate collocation matrices</span>
ntA = nrA * nzA; <span class="comment">% Total grid points in full domain</span>
nt = nr .* nz; <span class="comment">% Grid points per block</span>
</pre>
            <h2 id="6">Equation Pointers and Projection Matrices</h2>
            <pre class="codeinput">pointers6; <span class="comment">% Call pointers6 to set up equation indices and projections</span>
</pre>
            <h2 id="7">Variable Initialization</h2>
            <pre class="codeinput">idx = 1;
<span class="keyword">for</span> k = 1:Nblock
    <span class="keyword">for</span> v = 1:NVAR(k)
        eval(sprintf(<span class="string">'%s%d = zeros(nr(%d), nz(%d));'</span>, list_varA{idx}, k, k, k));
        idx = idx + 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
            <h2 id="8">Physical Grid Generation</h2>
            <pre class="codeinput">rA = repmat(r0A', 1, nzA); <span class="comment">% Radial coordinates</span>
zA = repmat(z0A, nrA, 1); <span class="comment">% Axial coordinates</span>
rrA{1} = repmat((r0A(1:nr(1))/r0A(1))', 1, nzA); <span class="comment">% Normalized radial coords (block 1)</span>
rrA{2} = repmat((r0A(nr(1):nrA)/r0A(nrA))', 1, nzA); <span class="comment">% Normalized radial coords (block 2)</span>

<span class="comment">% Domain boundaries</span>
Rout = 6; <span class="comment">% Outer wall y-coordinate</span>
L1 = 6; <span class="comment">% Inlet x-coordinate</span>
L2 = 16; <span class="comment">% Outlet x-coordinate</span>

<span class="comment">% Mapping functions for grid</span>
[~, j01] = min(abs(z0A - 0.25)); <span class="comment">% Left stagnation point index</span>
[~, j02] = min(abs(z0A - 0.5)); <span class="comment">% Right stagnation point index</span>
x1 = z0A(1:j01) / z0A(j01);
x2 = (z0A(j01:j02) - z0A(j01)) / (z0A(j02) - z0A(j01));
x3 = (z0A(j02:nzA) - z0A(j02)) / (z0A(nzA) - z0A(j02));
g0{1} = [-L1 + x1*(L1-1), -cos(pi*x2(2:end-1)), 1 + x3*(L2-1)]; <span class="comment">% Block 1 x-mapping</span>
f0{1} = [zeros(1, length(x1)), -sin(pi*x2(2:end-1)), zeros(1, length(x3))]; <span class="comment">% Block 1 y-mapping</span>
g1{1} = g0{1}; <span class="comment">% Block 1 outer x-boundary</span>
f1{1} = -Rout * ones(1, nzA); <span class="comment">% Block 1 outer y-boundary</span>
g0{2} = g0{1}; <span class="comment">% Block 2 x-mapping</span>
f0{2} = [zeros(1, length(x1)), sin(pi*x2(2:end-1)), zeros(1, length(x3))]; <span class="comment">% Block 2 y-mapping</span>
g1{2} = g0{1}; <span class="comment">% Block 2 outer x-boundary</span>
f1{2} = Rout * ones(1, nzA); <span class="comment">% Block 2 outer y-boundary</span>

<span class="comment">% Generate initial mesh</span>
<span class="keyword">for</span> k = 1:Nblock
    z1 = zA(Ia(k):Ib(k), Ja(k):Jb(k));
    r1 = rrA{k};
    g00 = repmat(g0{k}, nr(k), 1);
    g11 = repmat(g1{k}, nr(k), 1);
    f00 = repmat(f0{k}, nr(k), 1);
    f11 = repmat(f1{k}, nr(k), 1);
    eval(sprintf(<span class="string">'F%d = f00 + (f11 - f00) .* r1;'</span>, k)); <span class="comment">% y-coordinates</span>
    eval(sprintf(<span class="string">'G%d = g00 + (g11 - g00) .* r1;'</span>, k)); <span class="comment">% x-coordinates</span>
<span class="keyword">end</span>

<span class="comment">% Combine borders for full domain</span>
Y1 = [F1; zeros(nr(2)-1, nzA)]; <span class="comment">% Block 1 y-border</span>
X1 = [G1; zeros(nr(2)-1, nzA)]; <span class="comment">% Block 1 x-border</span>
Y2 = [zeros(nr(1)-1, nzA); F2]; <span class="comment">% Block 2 y-border</span>
X2 = [zeros(nr(1)-1, nzA); G2]; <span class="comment">% Block 2 x-border</span>
ndA = reshape(ndA, 1, ntA); <span class="comment">% Flatten equation indices</span>
Y1 = reshape(Y1, ntA, 1); <span class="comment">% Flatten y-coordinates</span>
Y2 = reshape(Y2, ntA, 1);
X1 = reshape(X1, ntA, 1); <span class="comment">% Flatten x-coordinates</span>
X2 = reshape(X2, ntA, 1);
</pre>
            <h2 id="9">Full Variable Expansion</h2>
            <pre class="codeinput">lv = 0;
<span class="keyword">for</span> k = 1:Nblock
    <span class="keyword">for</span> i = 1:NVAR(k)
        lv = lv + 1;
        variable_name = list_var{k}{i};
        eval(sprintf(<span class="string">'%s%dfull = reshape(PNMv{%d} * reshape(%s%d, ntv(%d), 1), nrA, nzA);'</span>, <span class="keyword">...</span>
            variable_name, k, lv, variable_name, k, lv));
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
            <h2 id="10">Simulation Parameters</h2>
            <pre class="codeinput">Re = 10; <span class="comment">% Reynolds number</span>
pa = [Re; Rout; L1; L2; 0; 0; 0; 0]; <span class="comment">% Parameter vector</span>
redeabletoxooptima; <span class="comment">% Initial guess for x0 and x0full</span>
x0mfull = x0full; <span class="comment">% Previous time step solution</span>
x0mmfull = x0mfull; <span class="comment">% Previous-previous time step solution</span>
</pre>
            <h2 id="11">Time Integration</h2>
            <pre class="codeinput">dt = 1e10; <span class="comment">% Large time step for steady-state</span>
dt1 = 1e10;
Ntimesteps = 1;
<span class="keyword">for</span> ll = 1:Ntimesteps
    error = 1e9; <span class="comment">% Initial error</span>
    iter = 0;
    <span class="keyword">while</span> error &gt; 1e-3 &amp;&amp; iter &lt; 300
        iter = iter + 1;
        matrixAB; <span class="comment">% Assemble system matrices</span>
        dxa = a \ b; <span class="comment">% Solve for update</span>
        error = max(abs(dxa)); <span class="comment">% Compute maximum error</span>
        <span class="keyword">if</span> error &gt; 1e9, error(<span class="string">'Divergence detected'</span>); <span class="keyword">end</span>
        x0 = x0 + (iter &lt; 6) * 0.05 * dxa + (iter &gt;= 6) * dxa; <span class="comment">% Apply update with under-relaxation</span>
        xotoredeableoptima; <span class="comment">% Update variables</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
            <h2 id="12">Visualization</h2>
            <pre class="codeinput">velocity(G1, G2, F1, F2, vx1, vx2); <span class="comment">% Plot x-velocity</span>
</pre>
            <p class="footer">
                <br>
                <a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
                <br>
            </p>
        </div>
        <div class="card mb-4">
            <div class="card-body">
                <h2 id="results" class="card-title">Results</h2>
                <p>
                    After completing the simulation, the results can be visualized and analyzed to understand the behavior of the system. 
                    Below are some key aspects to consider when interpreting the results:
                </p>
                <ul>
                    <li><strong>Velocity Fields:</strong> Examine the velocity distribution in the domain to identify flow patterns, stagnation points, and regions of high shear.</li>
                    <li><strong>Pressure Distribution:</strong> Analyze the pressure contours to understand the forces acting on the fluid and the boundaries.</li>
                    <li><strong>Streamlines:</strong> Visualize the streamlines to observe the flow trajectories and identify recirculation zones.</li>
                    <li><strong>Validation:</strong> Compare the numerical results with analytical solutions or experimental data to validate the accuracy of the simulation.</li>
                </ul>
                <p>
                    The visualization tools provided in the code, such as the  <a href="velocity.html" target="_blank">velocity.m</a> function, can be used to generate contours of the velocity components and other variables. 
                    For example, Figure 2 shows contours of the x-velocity for Re=10.
                </p>
                <figure id="figure2" class="text-center">
                    <img src="figure2.png" alt="Contours of x-velocity for Re=10" class="img-fluid" style="max-width: 40%;">
                    <figcaption>Figure 2: Contours of x-velocity for Re=10.</figcaption>
                </figure>
                <p>
                    By analyzing the results, you can gain insights into the physical phenomena being modeled and assess the performance of the JAM framework in solving complex problems.
                </p>
            </div>
        </div>
    </div>        

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'929fca3f0e107b98',t:'MTc0MzU5MTI4NS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>